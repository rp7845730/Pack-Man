/*
 * Project name:
     pli.mcpar
 * Generated by:
     Visual TFT
 * Date of creation
     11/27/2023
 * Test configuration:
     MCU:             STM32F107VC
     Dev.Board:       EasyMx_PRO_v7_for_STM32_ARM_9A
     Oscillator:      72000000 Hz
     SW:              mikroC PRO for ARM
                      http://www.mikroe.com/mikroc/arm/
 */



 #include "pli_objects.h"
 #include "pli_resources.h"



 unsigned int Screenstatemachine = 0;
  #define FRUITSIZE 5
  #define FLAGSIZE 10
  #define BOUNUSSIZE 15
 int adcval;
 int YOUR_SCORE;
struct flags {
int x0;
int x1;
int y0;
int y1;
int color;
};

struct bounus{
int x0;
int x1;
int y0;
int y1;
int color;
};

struct fruit{
 int a0;
 int b0;
 int a1;
 int b1;
 int color;
};
struct bounus bounus1, bounus2, bounus3;
struct fruit  fruit1, fruit2, fruit3;
struct flags flag1,flag2, flag3, flag4, flag5;
void Randomizeflag (struct flags myflag);
void Randomizefruit (struct fruit myfruit);
 void Randomizebounus (struct bounus mybounus);
 void InitializeUSART1();



void main() {
Start_TP();

  Joystick_configuration();
   starting();
     Randomizeflag(flag1);
     delay_ms(5000);
     Randomizefruit(fruit1);
     delay_ms(5000);
     Randomizebounus(bounus1);
     delay_ms(5000);
     Randomizeflag(flag2);
      delay_ms(5000);
     Randomizebounus (bounus2);
      delay_ms(5000);
     Randomizebounus (bounus3);
     delay_ms(5000);
       Randomizeflag(flag3);
       delay_ms(5000);
     Randomizeflag(flag4);
    InitializeUSART1();
    ADCconfiguration();
 //**************************************************************************************************
 //VARIABLE DECLARATIONS
  for(;;) {
 // The peripheral registers can be accessed by half-words (16-bit) or words (32-bit).
 // Per data sheet (pg. 1007) USART1_SR consists of the following:
 // 9 8 7 6 5 4 3 2 1 0
 //CTS LBD TXE TC RXNE IDLE ORE NE FE PE
 while (!((USART1_SR & (1<<5))== 0x20)){} // Check RXNE in USART1 Status Register.
 // while receiver data register is empty, wait
 // You can also check RXNE directly
 // while (!USART1_SR.RXNE = 1) {} //while receiver data register is empty wait

 // When data becomes available, we can store it on the CPU in a variable. Data is put into
 // the USART data register USART1_DR (pg. 1010)
 ADC1_DR = USART1_DR; //read data from receiver data register
 //while transmitter data register is not empty wait
 while (! (USART1_SR & (1<<7)) == 0x80) {}
 // If we want to send data out via USART, we use the same data register
 USART1_DR = ADC1_DR;
 Soft_UART_Write(YOUR_SCORE);
 }




  while (1) {


  }


 }


  void Randomizeflag (struct flags myflag){
  myflag.x0 = rand()/108;
  myflag.x0 += FLAGSIZE+(myflag.x1 % FLAGSIZE);
  myflag.y0 = rand()/145;
  myflag.y0 += FLAGSIZE+(myflag.y1 % FLAGSIZE);

  myflag.x1 = myflag.x0 + FLAGSIZE;
  myflag.y1 = myflag.y0 + FLAGSIZE;

  TFT_SET_Brush(1, CL_LIME,0,0,0,0);
  TFT_Rectangle(myflag.x0, myflag.y0, myflag.x1, myflag.y1);
 }

 void Randomizebounus (struct bounus mybounus){
  mybounus.x0 = rand()/165;
  mybounus.x0 += BOUNUSSIZE-(mybounus.x1 % BOUNUSSIZE);
  mybounus.y0 = rand()/5;
  mybounus.y0 += BOUNUSSIZE-(mybounus.y1 % BOUNUSSIZE);

  mybounus.x1 = mybounus.x0 + BOUNUSSIZE;
  mybounus.y1 = mybounus.y0 + BOUNUSSIZE;

  TFT_SET_Brush(1, CL_WHITE,0,0,0,0);
  TFT_Rectangle_Round_Edges(mybounus.x0, mybounus.y0, mybounus.x1, mybounus.y1, 5);

 }


 void Randomizefruit (struct fruit myfruit){

  myfruit.a0 = rand()/35;
  myfruit.b0 = rand()/93;
  myfruit.a1 =  80;
  myfruit.b1 = 50;
  TFT_SET_Brush(1, CL_GREEN,0,0,0,0);
  TFT_Circle(myfruit.a0, myfruit.b0, 5);
  TFT_SET_Brush(1, CL_GREEN,0,0,0,0);
  TFT_Circle(myfruit.a1, myfruit.b1, 5);
 }
 void InitializeUSART1(){ // Sub function which initializes the registers to enable USART1
 RCC_APB2ENR |= 1; // Enable clock for Alt. Function. USART1 uses AF for PA9/PA10
 AFIO_MAPR=0X0F000000; // Do not mask PA9 and PA10 (becaue we are using for USART)
 RCC_APB2ENR |= 1<<2; // Enable clock for GPIOA
 GPIOA_CRH &= ~(0xFF << 4); // Clear PA9, PA10
 GPIOA_CRH |= (0x0B << 4); // USART1 Tx (PA9) output push-pull
 GPIOA_CRH |= (0x04 << 8); // USART1 Rx (PA10) input floating
 RCC_APB2ENR |= 1<<14; // enable clock for USART1
 USART1_BRR=0X00000506; // Set baud rate to 56000
 USART1_CR1 &= ~(1<<12); // Force 8 data bits. M bit is set to 0.
 USART1_CR2 &= ~(3<<12); // Force 1 stop bit
 USART1_CR3 &= ~(3<<8); // Force no flow control and no DMA for USART1
 USART1_CR1 &= ~(3<<9); // Force no parity and no parity control
 USART1_CR1 |= 3<<2; // RX, TX enable
 //The following two instructions can also be used to enable RX and TX manually
 //USART1_CR1.TE=1; //TX enable
 //USART1_CR1.RE=1; //RX enable
 USART1_CR1 |= 1<<13; // USART1 enable. This is done after configuration is complete
 Delay_ms(100); // Wait for USART to complete configuration and enable.

 }